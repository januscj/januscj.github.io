<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><entry>
<title type="html">jdk源码阅读之ThreadLocal</title>
<link href="http://januscj.github.io/2015/10/18/jdk-yuan-ma-zhi-threadlocal/"/>
<updated>2015-10-18T20:40:24+08:00</updated>
<id>http://januscj.github.io/2015/10/18/jdk-yuan-ma-zhi-threadlocal</id>
<content type="html">&lt;p&gt;并发编程中，另一个常用的工具是Threadlocal.今天来一探其神秘面纱。
我们最常用的是Threadlocal的set方法，下面从set方法的源码入手:&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocal.ThreadLocalMap map = this.getMap(t);
        if(map != null) {
            map.set(this, value);
        } else {
            this.createMap(t, value);
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码来看，先回调用getMap判断ThreadLocalMap是否存在，getMap的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
  ThreadLocal.ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它实际上就是Thread对象的一个成员变量。再回到set方法，如果当前Thread对象的threadLocals没有设置，则会调用createMap创建新的ThreadlocalMap。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
  void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocal.ThreadLocalMap(this, firstValue);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将当前ThreadLocal对象和传给ThreadLocalMap。&lt;/p&gt;

&lt;p&gt;下面来看看ThreadLocalMap的构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;        ThreadLocalMap(ThreadLocal firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ThreadLocalMap实际上只是一个数组,第一个entry的放入位置是根据firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)来计算的。ThreadLocal的threadLocalHashCode是0x61c88647累加得到的,而0x61c88647是黄金比例Math.sqrt(5) - 1左移31位得到。&lt;/p&gt;

&lt;p&gt;再回到set方法，如果Thread的threadlocal已存在，则直接调用ThreadLocalMap的set，源码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private void set(ThreadLocal key, Object value) {

            // We don't use a fast path as with get() because it is at
            // least as common to use set() to create new entries as
            // it is to replace existing ones, in which case, a fast
            // path would fail more often than not.

            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp; (len-1);

            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                ThreadLocal k = e.get();

                if (k == key) {
                    e.value = value;
                    return;
                }

                if (k == null) {
                    replaceStaleEntry(key, value, i);
                    return;
                }
            }

            tab[i] = new Entry(key, value);
            int sz = ++size;
            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
                rehash();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set方法会先判断map中是否有同一个ThreadLocal，如果有就使用当前的value覆盖调原来的value。如果原来的threadlocal为null(被回收掉了)，则直接使用当前的key/value替换掉原来的threadlocal。否则，找到一个空的位置把当前的Entry填进去。&lt;/p&gt;

&lt;p&gt;下面看看get方法的源码
&lt;code&gt;java
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null)
                return (T)e.value;
        }
        return setInitialValue();
    }
&lt;/code&gt;
get方法很简单就是从Thread的ThreadLocalMap中取，如果没有取到，则初始化数据到map中。&lt;/p&gt;

&lt;p&gt;ThreadLocal的remove是直接调用ThreadLocalMap的remove方法，源码如下
```java
        private void remove(ThreadLocal key) {
            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp; (len-1);
            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                if (e.get() == key) {
                    e.clear();
                    expungeStaleEntry(i);
                    return;
                }
            }&lt;/p&gt;

&lt;p&gt;```
从代码来看，如果找到则会调用Entry的clear，接着调用expungeStaleEntry移除entry。&lt;/p&gt;

&lt;p&gt;通读源码知道，ThreadLocalMap的设计思想跟HashMap是不一样的，HashMap实用链表来解决冲突，而ThreadLocalMap实用是开放地址的算法来解决冲突，同时在set的时候会移除stale entry，来保证数组不会太慢，导致多次rehash。&lt;/p&gt;
</content>
</entry><entry>
<title type="html">jdk源码阅读之ReentrantReadWriteLock</title>
<link href="http://januscj.github.io/2015/09/28/jdk-yuan-ma-zhi-reentrantreadwritelock/"/>
<updated>2015-09-28T19:14:56+08:00</updated>
<id>http://januscj.github.io/2015/09/28/jdk-yuan-ma-zhi-reentrantreadwritelock</id>
<content type="html">&lt;p&gt;了解完reentrantlock，再来看看reentrantreadwritelock。在看reentrantreadwritelock源码之前，得了解它的特点。我们都知道读锁跟写锁是互斥的，多个读线程可以同时进行读操作，就是说对锁对读线程来说是共享锁。写锁是独占锁，写锁之间也是互斥的。了解这些基本特性之后，再来看源码。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reentrantreadwritelock是通过上面的代码初始化的，从上面来看读锁跟写锁公用同一个同步器。因为一个同步器只有一个state变量，我们知道同步器使用state来标识线程的不同状态。&lt;strong&gt;那么，reentrantreadwritelock是怎么来区分读锁、写锁的，后面看过源码后知道,它是用state的高16位表示读锁，低16位表示写锁。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先来看读锁的获取，读锁获取首先是下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
protected final int tryAcquireShared(int unused) {
            /*
             * Walkthrough:
             * 1. If write lock held by another thread, fail.
             * 2. Otherwise, this thread is eligible for
             *    lock wrt state, so ask if it should block
             *    because of queue policy. If not, try
             *    to grant by CASing state and updating count.
             *    Note that step does not check for reentrant
             *    acquires, which is postponed to full version
             *    to avoid having to check hold count in
             *    the more typical non-reentrant case.
             * 3. If step 2 fails either because thread
             *    apparently not eligible or CAS fails or count
             *    saturated, chain to version with full retry loop.
             */
            Thread current = Thread.currentThread();
            int c = getState();
            if (exclusiveCount(c) != 0 &amp;&amp;
                getExclusiveOwnerThread() != current)
                return -1;
            int r = sharedCount(c);
            if (!readerShouldBlock() &amp;&amp;
                r &lt; MAX_COUNT &amp;&amp;
                compareAndSetState(c, c + SHARED_UNIT)) {
                if (r == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null || rh.tid != current.getId())
                        cachedHoldCounter = rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                }
                return 1;
            }
            return fullTryAcquireShared(current);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码来看，首先如果写锁已被其他线程持有，则直接阻塞当前线程。如果进入if分支，分三种情况：没有读线程持有锁，则直接设置firstReader、firstReaderHoldCount；否则，如果当前线程是第一个读线程，则firstReaderHoldCount+1；否则，创建一个HolderCounter对象来记录线程对读锁的持有次数，并将该HolderCounter对象放入ThreadLocal中。其他的情况（CAS失败或readerShouldBlock返回true），则进入fullTryAcquireShared。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
final int fullTryAcquireShared(Thread current) {
            /*
             * This code is in part redundant with that in
             * tryAcquireShared but is simpler overall by not
             * complicating tryAcquireShared with interactions between
             * retries and lazily reading hold counts.
             */
            HoldCounter rh = null;
            for (;;) {
                int c = getState();
                if (exclusiveCount(c) != 0) {
                    if (getExclusiveOwnerThread() != current)
                        return -1;
                    // else we hold the exclusive lock; blocking here
                    // would cause deadlock.
                } else if (readerShouldBlock()) {
                    // Make sure we're not acquiring read lock reentrantly
                    if (firstReader == current) {
                        // assert firstReaderHoldCount &gt; 0;
                    } else {
                        if (rh == null) {
                            rh = cachedHoldCounter;
                            if (rh == null || rh.tid != current.getId()) {
                                rh = readHolds.get();
                                if (rh.count == 0)
                                    readHolds.remove();
                            }
                        }
                        if (rh.count == 0)
                            return -1;
                    }
                }
                if (sharedCount(c) == MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                if (compareAndSetState(c, c + SHARED_UNIT)) {
                    if (sharedCount(c) == 0) {
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    } else if (firstReader == current) {
                        firstReaderHoldCount++;
                    } else {
                        if (rh == null)
                            rh = cachedHoldCounter;
                        if (rh == null || rh.tid != current.getId())
                            rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                        cachedHoldCounter = rh; // cache for release
                    }
                    return 1;
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fullTryAcquireShared首先会判断若其他线程持有写锁，则会阻塞。若readerShouldBlock返回true，则进入if分支，如果当前线程不是第一个读线程，同时当前线程是之前没有持有读锁，则会从ThreadLocal中移除HoldCounter，最后如果count仍是-1，则直接返回-1，阻塞当前线程。接着下来的代码就是对tryAcquireShared CAS state失败的处理，逻辑类似。&lt;/p&gt;

&lt;p&gt;下面来看读锁释放的逻辑:&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
protected final boolean tryReleaseShared(int unused) {
            Thread current = Thread.currentThread();
            if (firstReader == current) {
                // assert firstReaderHoldCount &gt; 0;
                if (firstReaderHoldCount == 1)
                    firstReader = null;
                else
                    firstReaderHoldCount--;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != current.getId())
                    rh = readHolds.get();
                int count = rh.count;
                if (count &lt;= 1) {
                    readHolds.remove();
                    if (count &lt;= 0)
                        throw unmatchedUnlockException();
                }
                --rh.count;
            }
            for (;;) {
                int c = getState();
                int nextc = c - SHARED_UNIT;
                if (compareAndSetState(c, nextc))
                    // Releasing the read lock has no effect on readers,
                    // but it may allow waiting writers to proceed if
                    // both read and write locks are now free.
                    return nextc == 0;
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，如果当前线程是第一个读线程，先判断读锁重入次数是否为1,如果为1，则直接将firstReader置null;否则，firstReaderHoldCount-1；否则，如果当前线程不是第一个读线程，则对持锁次数减1.下面的for循环是处理CAS state。&lt;/p&gt;

&lt;p&gt;下面接着来看写锁的获取锁的过程:&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
protected final boolean tryAcquire(int acquires) {
            /*
             * Walkthrough:
             * 1. If read count nonzero or write count nonzero
             *    and owner is a different thread, fail.
             * 2. If count would saturate, fail. (This can only
             *    happen if count is already nonzero.)
             * 3. Otherwise, this thread is eligible for lock if
             *    it is either a reentrant acquire or
             *    queue policy allows it. If so, update state
             *    and set owner.
             */
            Thread current = Thread.currentThread();
            int c = getState();
            int w = exclusiveCount(c);
            if (c != 0) {
                // (Note: if c != 0 and w == 0 then shared count != 0)
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                // Reentrant acquire
                setState(c + acquires);
                return true;
            }
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，从代码来看，&lt;strong&gt;如果是有读线程持有读锁或其他写线程持有锁，则当前写线程会阻塞&lt;/strong&gt;，如果是当前线程持有写锁，则将持锁次数加1。如果writerShouldBlock方法返回true或CAS state失败，则阻塞当前写线程；否则，设置当前线程为写锁持有者。&lt;/p&gt;

&lt;p&gt;写锁的释放过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
  protected final boolean tryRelease(int releases) {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            int nextc = getState() - releases;
            boolean free = exclusiveCount(nextc) == 0;
            if (free)
                setExclusiveOwnerThread(null);
            setState(nextc);
            return free;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;释放锁的代码很简单，因为是只有一个线程持有锁，所有是单线程的，sate的变更没有使用CAS。&lt;/p&gt;
</content>
</entry><entry>
<title type="html">jdk源码阅读之ReentrantLock</title>
<link href="http://januscj.github.io/2015/09/14/jdk-yuan-ma-zhi-reentrantlock/"/>
<updated>2015-09-14T11:06:57+08:00</updated>
<id>http://januscj.github.io/2015/09/14/jdk-yuan-ma-zhi-reentrantlock</id>
<content type="html">&lt;p&gt;接着来看并发工具类库另外一个常用的工具ReentrantLock。Reentrantlock也有公平策略和非公平策略,先来看非公平策略。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
static final class NonfairSync extends ReentrantLock.Sync {
        private static final long serialVersionUID = 7316153563782823691L;

        NonfairSync() {
        }

        final void lock() {
            if(this.compareAndSetState(0, 1)) {
                this.setExclusiveOwnerThread(Thread.currentThread());
            } else {
                this.acquire(1);
            }

        }

        protected final boolean tryAcquire(int acquires) {
            return this.nonfairTryAcquire(acquires);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非公平策略优先尝试cas state，如果没成功，则进入AQS的aquire。先来看Sync的nonfairTryAcquire。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
    final boolean nonfairTryAcquire(int acquires) {
            Thread current = Thread.currentThread();
            int c = this.getState();
            if(c == 0) {
                if(this.compareAndSetState(0, acquires)) {
                    this.setExclusiveOwnerThread(current);
                    return true;
                }
            } else if(current == this.getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if(nextc &lt; 0) {
                    throw new Error("Maximum lock count exceeded");
                }

                this.setState(nextc);
                return true;
            }

            return false;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法首先判断是否线程持有锁，如果没有则获取锁，并把线程所有者设置为当前线程。否则，判断当前线程是否是持有锁，如果是，则state+1，返回true。这里说明ReentrantLock是可重入的。如果别的线程已经获取锁，则返回false。如果返回false，这个时候，我们再来看acquire方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候进入acquireQueued。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
 final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码来看，这个时候线程会被park住，至此获取锁的过程分析完毕。下面，来看释放锁的过程。首先unlock调用的是release方法&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先来看tryRelease&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
 protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码来看，当state变为0，tryRelease才会返回true，release才会unpark第二个线程节点。这个时候回到acquireQueued方法，第二节点被unpark之后。仍在for循环里，这个时候把如果tryRelease返回true，即等待队列的第二个节点获得锁，进入if分支，把头结点设置为当前节点，并直接返回。等待队列的其他节点，依次类推。&lt;/p&gt;

&lt;p&gt;下面来说说公平策略好非公平策略的区别。跟Semaphore一样，公平策略会判断线程等待队列中是否有线程再等待，如果有则将当前线程放入等待队列，直到被被唤醒。但非公平策略是，不过当前是否有线程再等待，都尝试去获取锁，这样当前线程可能会优先获取到锁，所以是不公平的。&lt;/p&gt;

&lt;p&gt;另外，condition也是并发场景中用的较多的工具之一。我们来看看condition是怎么做的。首先看await方法&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
        public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            Node node = addConditionWaiter();
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，addConditionWaiter再condition队列为空的时候，构建condition队列，若condition队列不为空，则把当前线程节点添加到队尾。后面while循环里判断，当前节点是否已经已到线程同步队列。如果没有移动到线程同步队列，则park当前线程节点，至此线程则被阻塞住了，直到被唤醒，才会往下走。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
    private int checkInterruptWhileWaiting(Node node) {
            return Thread.interrupted() ?
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
                0;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果线程没有被中断，则会继续循环。再次判断当前节点是否在线程同步队列，如果在同步队列，则会结束循环。从后面代码知道，线程会在&lt;strong&gt;signal的时候移动到同步队列&lt;/strong&gt;。接着，会调用acquireQueued判断同步队列能否获得锁，不能则会被阻塞住。否则，会继续往下走。&lt;/p&gt;

&lt;p&gt;await的整个流程就如上面分析，下面来看看sigal的流程。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
    public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                doSignal(first);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的判断当前线程是否持有锁，如果是则往下走。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
        private void doSignal(Node first) {
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
            } while (!transferForSignal(first) &amp;&amp;
                     (first = firstWaiter) != null);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码来看，doSignal从第一个节点开始调用transferForSignal&lt;/p&gt;

&lt;pre&gt;&lt;code class="java "&gt;
  final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，尝试将node的state由-2更新为0，如果更新不成功，则继续循环，尝试唤醒下个节点;如果，更新成功，则将当前节点添加到线程同步队列。然后，把节点状态更新为-1，返回true，这样doSignal就做完了。&lt;/p&gt;

&lt;p&gt;ReentrantLock其实就是实现了线程间最基本的互斥和通信机制。&lt;/p&gt;
</content>
</entry>
<title>分类:jdk源码阅读 | Chin的博客</title>
<link href="http://januscj.github.io/categories/jdkyuan-ma-yue-du/atom.xml" rel="self"/>
<link href="http://januscj.github.io/"/>
<updated>2013-10-08T22:38:02+08:00</updated>
<id>http://januscj.github.io/</id>
<author>
<name>Chin</name>
</author>
<generator uri="http://octopress.org/">Octopress</generator>
<entry>
<title type="html">LinkedHashMap源码分析</title>
<link href="http://januscj.github.io/2013/10/06/linkedhashmapyuan-ma-fen-xi/"/>
<updated>2013-10-06T18:00:00+08:00</updated>
<id>http://januscj.github.io/2013/10/06/linkedhashmapyuan-ma-fen-xi</id>
<content type="html">&lt;p&gt;继之前看完hashMap的源码之后，最近又看以了一下LinkedHashMap的源码。发现LinkedHash的代码很简单，他是HashMap的子类，自然具有
父类的所以特性，除此之外他也有自己的特点。详细来说，它包含两种数据结构：1、从父类HashMap继承来的数据链表结构(见HashMap源码分析这篇文章)。2、自己的双向循环链表结构。前一
种数据结构的由来显而易见，后一种数据结构是怎么实现的呢？这久要从LinkedMap的对象创建说起：br/
LinkedHashMap最简单的构造函数是这样的：
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"public/span span class="n"LinkedHashMap/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'    span class="kd"super/spanspan class="o"();/span
/spanspan class='line'    span class="n"accessOrder/span span class="o"=/span span class="kc"false/spanspan class="o";/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
看出跟双向链表又任何关系，关键是下面这个方法：
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
/pre/tdtd class='code'precode class='java'span class='line'   span class="nd"@Override/spanspan class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kt"void/span span class="n"init/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'    span class="n"header/span span class="o"=/span span class="k"new/span span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";(-/spanspan class="mi"1/spanspan class="o",/span span class="kc"null/spanspan class="o",/span span class="kc"null/spanspan class="o",/span span class="kc"null/spanspan class="o");/span
/spanspan class='line'    span class="n"header/spanspan class="o"./spanspan class="na"before/span span class="o"=/span span class="n"header/spanspan class="o"./spanspan class="na"after/span span class="o"=/span span class="n"header/spanspan class="o";/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
这个方法是对HashMap中的init的覆盖，在HashMap的构造方法中调用。注意这里的Entry类是LinkedHashMap继承HashMap.Entry类的实现类：
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
span class='line-number'11/span
span class='line-number'12/span
span class='line-number'13/span
span class='line-number'14/span
span class='line-number'15/span
span class='line-number'16/span
span class='line-number'17/span
span class='line-number'18/span
span class='line-number'19/span
span class='line-number'20/span
span class='line-number'21/span
span class='line-number'22/span
span class='line-number'23/span
span class='line-number'24/span
span class='line-number'25/span
span class='line-number'26/span
span class='line-number'27/span
span class='line-number'28/span
span class='line-number'29/span
span class='line-number'30/span
span class='line-number'31/span
span class='line-number'32/span
span class='line-number'33/span
span class='line-number'34/span
span class='line-number'35/span
span class='line-number'36/span
span class='line-number'37/span
span class='line-number'38/span
span class='line-number'39/span
span class='line-number'40/span
span class='line-number'41/span
span class='line-number'42/span
span class='line-number'43/span
span class='line-number'44/span
span class='line-number'45/span
span class='line-number'46/span
span class='line-number'47/span
span class='line-number'48/span
span class='line-number'49/span
span class='line-number'50/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"private/span span class="kd"static/span span class="kd"class/span span class="nc"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="kd"extends/span span class="n"HashMap/spanspan class="o"./spanspan class="na"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="o"{/span
/spanspan class='line'    span class="c1"// These fields comprise the doubly linked list used for iteration./span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"before/spanspan class="o",/span span class="n"after/spanspan class="o";/span
/spanspan class='line'
/spanspan class='line'    span class="n"Entry/spanspan class="o"(/spanspan class="kt"int/span span class="n"hash/spanspan class="o",/span span class="n"K/span span class="n"key/spanspan class="o",/span span class="n"V/span span class="n"value/spanspan class="o",/span span class="n"HashMap/spanspan class="o"./spanspan class="na"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"next/spanspan class="o")/span span class="o"{/span
/spanspan class='line'        span class="kd"super/spanspan class="o"(/spanspan class="n"hash/spanspan class="o",/span span class="n"key/spanspan class="o",/span span class="n"value/spanspan class="o",/span span class="n"next/spanspan class="o");/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="cm"/**/span
/spanspan class='line'span class="cm"     * Removes this entry from the linked list./span
/spanspan class='line'span class="cm"     *//span
/spanspan class='line'    span class="kd"private/span span class="kt"void/span span class="nf"remove/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="n"before/spanspan class="o"./spanspan class="na"after/span span class="o"=/span span class="n"after/spanspan class="o";/span
/spanspan class='line'        span class="n"after/spanspan class="o"./spanspan class="na"before/span span class="o"=/span span class="n"before/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="cm"/**/span
/spanspan class='line'span class="cm"     * Inserts this entry before the specified existing entry in the list./span
/spanspan class='line'span class="cm"     *//span
/spanspan class='line'    span class="kd"private/span span class="kt"void/span span class="nf"addBefore/spanspan class="o"(/spanspan class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"existingEntry/spanspan class="o")/span span class="o"{/span
/spanspan class='line'        span class="n"after/span  span class="o"=/span span class="n"existingEntry/spanspan class="o";/span
/spanspan class='line'        span class="n"before/span span class="o"=/span span class="n"existingEntry/spanspan class="o"./spanspan class="na"before/spanspan class="o";/span
/spanspan class='line'        span class="n"before/spanspan class="o"./spanspan class="na"after/span span class="o"=/span span class="k"this/spanspan class="o";/span
/spanspan class='line'        span class="n"after/spanspan class="o"./spanspan class="na"before/span span class="o"=/span span class="k"this/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="cm"/**/span
/spanspan class='line'span class="cm"     * This method is invoked by the superclass whenever the value/span
/spanspan class='line'span class="cm"     * of a pre-existing entry is read by Map.get or modified by Map.set./span
/spanspan class='line'span class="cm"     * If the enclosing Map is access-ordered, it moves the entry/span
/spanspan class='line'span class="cm"     * to the end of the list; otherwise, it does nothing./span
/spanspan class='line'span class="cm"     *//span
/spanspan class='line'    span class="kt"void/span span class="nf"recordAccess/spanspan class="o"(/spanspan class="n"HashMap/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"m/spanspan class="o")/span span class="o"{/span
/spanspan class='line'        span class="n"LinkedHashMap/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"lm/span span class="o"=/span span class="o"(/spanspan class="n"LinkedHashMap/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";)/spanspan class="n"m/spanspan class="o";/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"lm/spanspan class="o"./spanspan class="na"accessOrder/spanspan class="o")/span span class="o"{/span
/spanspan class='line'            span class="n"lm/spanspan class="o"./spanspan class="na"modCount/spanspan class="o"++;/span
/spanspan class='line'            span class="n"remove/spanspan class="o"();/span
/spanspan class='line'            span class="n"addBefore/spanspan class="o"(/spanspan class="n"lm/spanspan class="o"./spanspan class="na"header/spanspan class="o");/span
/spanspan class='line'        span class="o"}/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="kt"void/span span class="nf"recordRemoval/spanspan class="o"(/spanspan class="n"HashMap/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"m/spanspan class="o")/span span class="o"{/span
/spanspan class='line'        span class="n"remove/spanspan class="o"();/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
成员变量多了before和after，还增加了一个addBefore方法。双向链表的初始化就是init方法中这行代码：
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
/pre/tdtd class='code'precode class='java'span class='line'   span class="n"header/spanspan class="o"./spanspan class="na"before/span span class="o"=/span span class="n"header/spanspan class="o"./spanspan class="na"after/span span class="o"=/span span class="n"header/spanspan class="o";/span
/span/code/pre/td/tr/table/div/figure/notextile/div  br/
即这个双向链表初始化完之后，只有一个header节点，header节点的key、value都为null。初始化完之后的结构是这样的：br/
img src="/images/linkedhashmap1.jpg"br/
再向LinkedHashMap添加一个元素之后的结构是这样的：br/br/
img src="/images/linkedhashmap2.jpg"br/
依次类推，最近添加的节点在最前面，紧跟在header节点之后。LinkedHashMap双向链表元素的添加主要是下面这段代码：/p

pdiv class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
span class='line-number'11/span
span class='line-number'12/span
span class='line-number'13/span
span class='line-number'14/span
span class='line-number'15/span
span class='line-number'16/span
span class='line-number'17/span
span class='line-number'18/span
span class='line-number'19/span
span class='line-number'20/span
span class='line-number'21/span
span class='line-number'22/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kt"void/span span class="n"addEntry/spanspan class="o"(/spanspan class="kt"int/span span class="n"hash/spanspan class="o",/span span class="n"K/span span class="n"key/spanspan class="o",/span span class="n"V/span span class="n"value/spanspan class="o",/span span class="kt"int/span span class="n"bucketIndex/spanspan class="o")/span span class="o"{/span
/spanspan class='line'    span class="kd"super/spanspan class="o"./spanspan class="na"addEntry/spanspan class="o"(/spanspan class="n"hash/spanspan class="o",/span span class="n"key/spanspan class="o",/span span class="n"value/spanspan class="o",/span span class="n"bucketIndex/spanspan class="o");/span
/spanspan class='line'
/spanspan class='line'    span class="c1"// Remove eldest entry if instructed/span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"eldest/span span class="o"=/span span class="n"header/spanspan class="o"./spanspan class="na"after/spanspan class="o";/span
/spanspan class='line'    span class="k"if/span span class="o"(/spanspan class="n"removeEldestEntry/spanspan class="o"(/spanspan class="n"eldest/spanspan class="o"))/span span class="o"{/span
/spanspan class='line'        span class="n"removeEntryForKey/spanspan class="o"(/spanspan class="n"eldest/spanspan class="o"./spanspan class="na"key/spanspan class="o");/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'
/spanspan class='line'span class="kt"void/span span class="nf"createEntry/spanspan class="o"(/spanspan class="kt"int/span span class="n"hash/spanspan class="o",/span span class="n"K/span span class="n"key/spanspan class="o",/span span class="n"V/span span class="n"value/spanspan class="o",/span span class="kt"int/span span class="n"bucketIndex/spanspan class="o")/span span class="o"{/span
/spanspan class='line'    span class="n"HashMap/spanspan class="o"./spanspan class="na"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"old/span span class="o"=/span span class="n"table/spanspan class="o"[/spanspan class="n"bucketIndex/spanspan class="o"];/span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"e/span span class="o"=/span span class="k"new/span span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";(/spanspan class="n"hash/spanspan class="o",/span span class="n"key/spanspan class="o",/span span class="n"value/spanspan class="o",/span span class="n"old/spanspan class="o");/span
/spanspan class='line'    span class="n"table/spanspan class="o"[/spanspan class="n"bucketIndex/spanspan class="o"]/span span class="o"=/span span class="n"e/spanspan class="o";/span
/spanspan class='line'    span class="n"e/spanspan class="o"./spanspan class="na"addBefore/spanspan class="o"(/spanspan class="n"header/spanspan class="o");/span
/spanspan class='line'    span class="n"size/spanspan class="o"++;/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
LinkedHashMap的这两个方法也是对HashMap的方法的覆盖，是由HashMap的put方法引起的调用。br/
LinkedHashMap的构造说完了，那它又是怎么迭代遍历元素的呢？同样LinkedHashMap实现了自己的迭代器：br/
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
span class='line-number'11/span
span class='line-number'12/span
span class='line-number'13/span
span class='line-number'14/span
span class='line-number'15/span
span class='line-number'16/span
span class='line-number'17/span
span class='line-number'18/span
span class='line-number'19/span
span class='line-number'20/span
span class='line-number'21/span
span class='line-number'22/span
span class='line-number'23/span
span class='line-number'24/span
span class='line-number'25/span
span class='line-number'26/span
span class='line-number'27/span
span class='line-number'28/span
span class='line-number'29/span
span class='line-number'30/span
span class='line-number'31/span
span class='line-number'32/span
span class='line-number'33/span
span class='line-number'34/span
span class='line-number'35/span
span class='line-number'36/span
span class='line-number'37/span
span class='line-number'38/span
span class='line-number'39/span
span class='line-number'40/span
span class='line-number'41/span
span class='line-number'42/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"private/span span class="kd"abstract/span span class="kd"class/span span class="nc"LinkedHashIterator/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"T/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="kd"implements/span span class="n"Iterator/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"T/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="o"{/span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"nextEntry/span    span class="o"=/span span class="n"header/spanspan class="o"./spanspan class="na"after/spanspan class="o";/span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"lastReturned/span span class="o"=/span span class="kc"null/spanspan class="o";/span
/spanspan class='line'
/spanspan class='line'    span class="cm"/**/span
/spanspan class='line'span class="cm"     * The modCount value that the iterator believes that the backing/span
/spanspan class='line'span class="cm"     * List should have.  If this expectation is violated, the iterator/span
/spanspan class='line'span class="cm"     * has detected concurrent modification./span
/spanspan class='line'span class="cm"     *//span
/spanspan class='line'    span class="kt"int/span span class="n"expectedModCount/span span class="o"=/span span class="n"modCount/spanspan class="o";/span
/spanspan class='line'
/spanspan class='line'    span class="kd"public/span span class="kt"boolean/span span class="nf"hasNext/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"return/span span class="n"nextEntry/span span class="o"!=/span span class="n"header/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="kd"public/span span class="kt"void/span span class="nf"remove/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"lastReturned/span span class="o"==/span span class="kc"null/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"IllegalStateException/spanspan class="o"();/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"modCount/span span class="o"!=/span span class="n"expectedModCount/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"ConcurrentModificationException/spanspan class="o"();/span
/spanspan class='line'
/spanspan class='line'        span class="n"LinkedHashMap/spanspan class="o"./spanspan class="na"this/spanspan class="o"./spanspan class="na"remove/spanspan class="o"(/spanspan class="n"lastReturned/spanspan class="o"./spanspan class="na"key/spanspan class="o");/span
/spanspan class='line'        span class="n"lastReturned/span span class="o"=/span span class="kc"null/spanspan class="o";/span
/spanspan class='line'        span class="n"expectedModCount/span span class="o"=/span span class="n"modCount/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"nextEntry/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"modCount/span span class="o"!=/span span class="n"expectedModCount/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"ConcurrentModificationException/spanspan class="o"();/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"nextEntry/span span class="o"==/span span class="n"header/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"NoSuchElementException/spanspan class="o"();/span
/spanspan class='line'
/spanspan class='line'        span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"e/span span class="o"=/span span class="n"lastReturned/span span class="o"=/span span class="n"nextEntry/spanspan class="o";/span
/spanspan class='line'        span class="n"nextEntry/span span class="o"=/span span class="n"e/spanspan class="o"./spanspan class="na"after/spanspan class="o";/span
/spanspan class='line'        span class="k"return/span span class="n"e/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
同样关键是nextEntry方法，故知LinkedHashMap是按照元素的放入顺序来迭代的，如果按before来迭代就是逆向迭代了。br/
LinkedHashMap作为一种特殊的HashMap，它也有随机访问的特性。看它的get方法代码：
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
span class='line-number'11/span
span class='line-number'12/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"public/span span class="n"V/span span class="n"get/spanspan class="o"(/spanspan class="n"Object/span span class="n"key/spanspan class="o")/span span class="o"{/span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"e/span span class="o"=/span span class="o"(/spanspan class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";)/spanspan class="n"getEntry/spanspan class="o"(/spanspan class="n"key/spanspan class="o");/span
/spanspan class='line'    span class="k"if/span span class="o"(/spanspan class="n"e/span span class="o"==/span span class="kc"null/spanspan class="o")/span
/spanspan class='line'        span class="k"return/span span class="kc"null/spanspan class="o";/span
/spanspan class='line'    span class="n"e/spanspan class="o"./spanspan class="na"recordAccess/spanspan class="o"(/spanspan class="k"this/spanspan class="o");/span
/spanspan class='line'    span class="k"return/span span class="n"e/spanspan class="o"./spanspan class="na"value/spanspan class="o";/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
跟HashMap的大同小异，访问方式同HashMap(见HashMap源码分析)。这个recordAccess方法值得注意，源码：
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
span class='line-number'11/span
span class='line-number'12/span
span class='line-number'13/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kt"void/span span class="n"recordAccess/spanspan class="o"(/spanspan class="n"HashMap/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"m/spanspan class="o")/span span class="o"{/span
/spanspan class='line'        span class="n"LinkedHashMap/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"lm/span span class="o"=/span span class="o"(/spanspan class="n"LinkedHashMap/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";)/spanspan class="n"m/spanspan class="o";/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"lm/spanspan class="o"./spanspan class="na"accessOrder/spanspan class="o")/span span class="o"{/span
/spanspan class='line'            span class="n"lm/spanspan class="o"./spanspan class="na"modCount/spanspan class="o"++;/span
/spanspan class='line'            span class="n"remove/spanspan class="o"();/span
/spanspan class='line'            span class="n"addBefore/spanspan class="o"(/spanspan class="n"lm/spanspan class="o"./spanspan class="na"header/spanspan class="o");/span
/spanspan class='line'        span class="o"}/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
从代码来看，若构造LinkedHashMap的时候accessOrder=true，那么在每次调用get访问的元素都会放到链表的最前端，即把最后后一次get访问的元素放在最前面，这种情况下LinkedHashMap就不是按元素的放入顺序来存放的，而是最近访问的在最前面。/p
</content>
</entry>
<entry>
<title type="html">HashMap源码分析</title>
<link href="http://januscj.github.io/2013/09/29/hashmapyuan-ma-fen-xi/"/>
<updated>2013-09-29T22:53:00+08:00</updated>
<id>http://januscj.github.io/2013/09/29/hashmapyuan-ma-fen-xi</id>
<content type="html">p通读hashMap的源代码之后，发现他的数据结构是这样的。br/
img src="/images/hashmap1.jpg"br/
阅读完源码知道，hashmap是会把indexFor()方法获得的index相同的那些entity放在数组的同一个位置，用一个next引用指向下一个entity，即index相同的entity组成了一个链表。这样来说，如果index的重复越多，链表越长，随机操作的效率就越低。那么jdk是如何计算index的呢？jdk中indexFor()方法的源码是:br/
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"static/span span class="kt"int/span span class="n"indexFor/spanspan class="o"(/spanspan class="kt"int/span span class="n"h/spanspan class="o",/span span class="kt"int/span span class="n"length/spanspan class="o")/span span class="o"{/span
/spanspan class='line'    span class="k"return/span span class="n"h/span span class="o"/spanspan class="n"amp/spanspan class="o";/span span class="o"(/spanspan class="n"length/spanspan class="o"-/spanspan class="mi"1/spanspan class="o");/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div/p

p其中leng是hashmap的大小，而h是key的hashCode经过hash()方法处理的结构，hash()方法源码：br/
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
span class='line-number'11/span
span class='line-number'12/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"static/span span class="kt"int/span span class="n"hash/spanspan class="o"(/spanspan class="kt"int/span span class="n"h/spanspan class="o")/span span class="o"{/span
/spanspan class='line'    span class="c1"// This function ensures that hashCodes that differ only by/span
/spanspan class='line'    span class="c1"// constant multiples at each bit position have a bounded/span
/spanspan class='line'    span class="c1"// number of collisions (approximately 8 at default load factor)./span
/spanspan class='line'    span class="n"h/span span class="o"^=/span span class="o"(/spanspan class="n"h/span span class="o"/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/span span class="mi"20/spanspan class="o")/span span class="o"^/span span class="o"(/spanspan class="n"h/span span class="o"/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/span span class="mi"12/spanspan class="o");/span
/spanspan class='line'    span class="k"return/span span class="n"h/span span class="o"^/span span class="o"(/spanspan class="n"h/span span class="o"/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/span span class="mi"7/spanspan class="o")/span span class="o"^/span span class="o"(/spanspan class="n"h/span span class="o"/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/spanspan class="n"gt/spanspan class="o";/span span class="mi"4/spanspan class="o");/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/divbr/
都说遍历hashmap的时候不一定是按照元素放入的顺序来迭代的，这是怎么回事呢？来看hashmap迭代的关键代码:
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
span class='line-number'11/span
span class='line-number'12/span
span class='line-number'13/span
span class='line-number'14/span
span class='line-number'15/span
span class='line-number'16/span
span class='line-number'17/span
span class='line-number'18/span
span class='line-number'19/span
span class='line-number'20/span
span class='line-number'21/span
span class='line-number'22/span
span class='line-number'23/span
span class='line-number'24/span
span class='line-number'25/span
span class='line-number'26/span
span class='line-number'27/span
span class='line-number'28/span
span class='line-number'29/span
span class='line-number'30/span
span class='line-number'31/span
span class='line-number'32/span
span class='line-number'33/span
span class='line-number'34/span
span class='line-number'35/span
span class='line-number'36/span
span class='line-number'37/span
span class='line-number'38/span
span class='line-number'39/span
span class='line-number'40/span
span class='line-number'41/span
span class='line-number'42/span
span class='line-number'43/span
span class='line-number'44/span
span class='line-number'45/span
span class='line-number'46/span
span class='line-number'47/span
span class='line-number'48/span
span class='line-number'49/span
span class='line-number'50/span
span class='line-number'51/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"private/span span class="kd"abstract/span span class="kd"class/span span class="nc"HashIterator/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"E/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="kd"implements/span span class="n"Iterator/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"E/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="o"{/span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"next/spanspan class="o";/span        span class="c1"// next entry to return/span
/spanspan class='line'    span class="kt"int/span span class="n"expectedModCount/spanspan class="o";/span   span class="c1"// For fast-fail/span
/spanspan class='line'    span class="kt"int/span span class="n"index/spanspan class="o";/span              span class="c1"// current slot/span
/spanspan class='line'    span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"current/spanspan class="o";/span     span class="c1"// current entry/span
/spanspan class='line'
/spanspan class='line'    span class="n"HashIterator/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="n"expectedModCount/span span class="o"=/span span class="n"modCount/spanspan class="o";/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"size/span span class="o"/spanspan class="n"gt/spanspan class="o";/span span class="mi"0/spanspan class="o")/span span class="o"{/span span class="c1"// advance to first entry/span
/spanspan class='line'            span class="n"Entry/spanspan class="o"[]/span span class="n"t/span span class="o"=/span span class="n"table/spanspan class="o";/span
/spanspan class='line'            span class="k"while/span span class="o"(/spanspan class="n"index/span span class="o"/spanspan class="n"lt/spanspan class="o";/span span class="n"t/spanspan class="o"./spanspan class="na"length/span span class="o"/spanspan class="n"amp/spanspan class="o";/spanspan class="n"amp/spanspan class="o";/span span class="o"(/spanspan class="n"next/span span class="o"=/span span class="n"t/spanspan class="o"[/spanspan class="n"index/spanspan class="o"++])/span span class="o"==/span span class="kc"null/spanspan class="o")/span
/spanspan class='line'                span class="o";/span
/spanspan class='line'        span class="o"}/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="kd"public/span span class="kd"final/span span class="kt"boolean/span span class="nf"hasNext/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"return/span span class="n"next/span span class="o"!=/span span class="kc"null/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="kd"final/span span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"nextEntry/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"modCount/span span class="o"!=/span span class="n"expectedModCount/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"ConcurrentModificationException/spanspan class="o"();/span
/spanspan class='line'        span class="n"Entry/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o",/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="n"e/span span class="o"=/span span class="n"next/spanspan class="o";/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"e/span span class="o"==/span span class="kc"null/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"NoSuchElementException/spanspan class="o"();/span
/spanspan class='line'
/spanspan class='line'        span class="k"if/span span class="o"((/spanspan class="n"next/span span class="o"=/span span class="n"e/spanspan class="o"./spanspan class="na"next/spanspan class="o")/span span class="o"==/span span class="kc"null/spanspan class="o")/span span class="o"{/span
/spanspan class='line'            span class="n"Entry/spanspan class="o"[]/span span class="n"t/span span class="o"=/span span class="n"table/spanspan class="o";/span
/spanspan class='line'            span class="k"while/span span class="o"(/spanspan class="n"index/span span class="o"/spanspan class="n"lt/spanspan class="o";/span span class="n"t/spanspan class="o"./spanspan class="na"length/span span class="o"/spanspan class="n"amp/spanspan class="o";/spanspan class="n"amp/spanspan class="o";/span span class="o"(/spanspan class="n"next/span span class="o"=/span span class="n"t/spanspan class="o"[/spanspan class="n"index/spanspan class="o"++])/span span class="o"==/span span class="kc"null/spanspan class="o")/span
/spanspan class='line'                span class="o";/span
/spanspan class='line'        span class="o"}/span
/spanspan class='line'        span class="n"current/span span class="o"=/span span class="n"e/spanspan class="o";/span
/spanspan class='line'        span class="k"return/span span class="n"e/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'
/spanspan class='line'    span class="kd"public/span span class="kt"void/span span class="nf"remove/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"current/span span class="o"==/span span class="kc"null/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"IllegalStateException/spanspan class="o"();/span
/spanspan class='line'        span class="k"if/span span class="o"(/spanspan class="n"modCount/span span class="o"!=/span span class="n"expectedModCount/spanspan class="o")/span
/spanspan class='line'            span class="k"throw/span span class="k"new/span span class="nf"ConcurrentModificationException/spanspan class="o"();/span
/spanspan class='line'        span class="n"Object/span span class="n"k/span span class="o"=/span span class="n"current/spanspan class="o"./spanspan class="na"key/spanspan class="o";/span
/spanspan class='line'        span class="n"current/span span class="o"=/span span class="kc"null/spanspan class="o";/span
/spanspan class='line'        span class="n"HashMap/spanspan class="o"./spanspan class="na"this/spanspan class="o"./spanspan class="na"removeEntryForKey/spanspan class="o"(/spanspan class="n"k/spanspan class="o");/span
/spanspan class='line'        span class="n"expectedModCount/span span class="o"=/span span class="n"modCount/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
通关HashIterator的构造方法和nextEntry方法知:bentrySet是按深度优先遍历的/b，即构造完之后next会指向第一个不为null的元素，迭代的时候nextEntry返回当前元素，在结束的时候
next指向下一个不为空的元素，没有元素，则next为null，依次往下遍历直到next为null。 br/
此外key和value的迭代hashmap都是以此类作为父类，写了自己的实现类。key的迭代类KeyIterator:
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"private/span span class="kd"final/span span class="kd"class/span span class="nc"KeyIterator/span span class="kd"extends/span span class="n"HashIterator/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"K/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="o"{/span
/spanspan class='line'    span class="kd"public/span span class="n"K/span span class="nf"next/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"return/span span class="nf"nextEntry/spanspan class="o"()./spanspan class="na"getKey/spanspan class="o"();/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
value的迭代类ValueIterator：
div class='bogus-wrapper'notextilefigure class='code' div class="highlight"tabletrtd class="gutter"pre class="line-numbers"span class='line-number'1/span
span class='line-number'2/span
span class='line-number'3/span
span class='line-number'4/span
span class='line-number'5/span
span class='line-number'6/span
span class='line-number'7/span
span class='line-number'8/span
span class='line-number'9/span
span class='line-number'10/span
/pre/tdtd class='code'precode class='java'span class='line'span class="o"//spanspan class="n"p/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"pre/spanspan class="o"/spanspan class="n"code/spanspan class="o"/spanspan class="kd"private/span span class="kd"final/span span class="kd"class/span span class="nc"ValueIterator/span span class="kd"extends/span span class="n"HashIterator/spanspan class="o"/spanspan class="n"lt/spanspan class="o";/spanspan class="n"V/spanspan class="o"/spanspan class="n"gt/spanspan class="o";/span span class="o"{/span
/spanspan class='line'    span class="kd"public/span span class="n"V/span span class="nf"next/spanspan class="o"()/span span class="o"{/span
/spanspan class='line'        span class="k"return/span span class="nf"nextEntry/spanspan class="o"()./spanspan class="na"value/spanspan class="o";/span
/spanspan class='line'    span class="o"}/span
/spanspan class='line'span class="o"}/span
/spanspan class='line'span class="o"//spanspan class="n"code/spanspan class="o"//spanspan class="n"pre/spanspan class="o"/span
/spanspan class='line'
/spanspan class='line'span class="o"/spanspan class="n"p/spanspan class="o"/span
/span/code/pre/td/tr/table/div/figure/notextile/div
由此看，jdk的代码的面向对象设计是相当出色的，以后项目的架构设计可以很好的参考jdk。到此，之前的大部分疑问都解决了。还有几个疑问的是，
其中一个就是，我们都知道hashmap在迭代的时候是不能修改的，那我们来看一下代码这是怎么回事呢？br/
在hashmap的几个修改方法中都会判断modCount != expectedModCount，如果这两个值不等就会抛出ConcurrentModificationException。
HashIterator构造的时候expectedModCount = modCount;迭代的时候不会修改expctedModCount和modCount,但put、remove都会修改modCount，故在迭代的时候会导致抛出
ConcurrentModificationException。看过官方的文档注释，貌似是为了防止hashmap在多线程下被修改，但问题是这样hashmap在单线程下也不能修改了，我认为这是一个不好的设计。
我想多线程环境没有人会想到用hashmap不做任何同步处理，那样出问题的风险太大了。所以hashmap本身应该只是针对单线程环境的，那就没必要有这样的设计。/p
</content>
</entry>
<entry>
<title type="html">Jdk源码阅读之semaphore</title>
<link href="http://januscj.github.io/2015/09/04/jdk-yuan-ma-zhi-semaphore/"/>
<updated>2015-09-04T15:18:34+08:00</updated>
<id>http://januscj.github.io/2015/09/04/jdk-yuan-ma-zhi-semaphore</id>
<content type="html">&lt;p&gt;前面看过AQS的源码后，对AQS的原理有了叫深入的理解，现在可以看看基于AQS的各种并发工具了，Semaphore是其中使用最普遍的一个。它的源码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
public class Semaphore implements java.io.Serializable {
    private static final long serialVersionUID = -3222578661600680210L;
    /** All mechanics via AbstractQueuedSynchronizer subclass */
    private final Sync sync;

    /**
     * Synchronization implementation for semaphore.  Uses AQS state
     * to represent permits. Subclassed into fair and nonfair
     * versions.
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 1192457210091910933L;

        Sync(int permits) {
            setState(permits);
        }

        final int getPermits() {
            return getState();
        }

        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }

        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next &lt; current) // overflow
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;
            }
        }

        final void reducePermits(int reductions) {
            for (;;) {
                int current = getState();
                int next = current - reductions;
                if (next &gt; current) // underflow
                    throw new Error("Permit count underflow");
                if (compareAndSetState(current, next))
                    return;
            }
        }

        final int drainPermits() {
            for (;;) {
                int current = getState();
                if (current == 0 || compareAndSetState(current, 0))
                    return current;
            }
        }
    }

    /**
     * NonFair version
     */
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = -2694183684443567898L;

        NonfairSync(int permits) {
            super(permits);
        }

        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }

    /**
     * Fair version
     */
    static final class FairSync extends Sync {
        private static final long serialVersionUID = 2014338818796000944L;

        FairSync(int permits) {
            super(permits);
        }

        protected int tryAcquireShared(int acquires) {
            for (;;) {
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟CountDownLatch一样，Semaphore也是使用组合的方式来使用AQS，内部定义了两个AQS之类，NonfairSync和FairSync。他们的区别是什么呢？稍后详解。使用下面的构造函数，创建的Semaphore对象是使用NonfairSync方式&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
    public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NonfairSync类&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
  static final class NonfairSync extends Sync {
        private static final long serialVersionUID = -2694183684443567898L;

        NonfairSync(int permits) {
            super(permits);
        }

        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sync类&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
   abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 1192457210091910933L;

        Sync(int permits) {
            setState(permits);
        }

        final int getPermits() {
            return getState();
        }

        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }

        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next &lt; current) // overflow
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;
            }
        }

        final void reducePermits(int reductions) {
            for (;;) {
                int current = getState();
                int next = current - reductions;
                if (next &gt; current) // underflow
                    throw new Error("Permit count underflow");
                if (compareAndSetState(current, next))
                    return;
            }
        }

        final int drainPermits() {
            for (;;) {
                int current = getState();
                if (current == 0 || compareAndSetState(current, 0))
                    return current;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过nonfairTryAcquireShared方法知道，线程在未获取到许可的情况下，线程会被方法等待队列。&lt;strong&gt;这种情况下，如果有许可释放出来，另外的线程可能比等待队列的线程先获取到许可&lt;/strong&gt;，所以是nonfair的。我们来看看释放许可的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
       protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next &lt; current) // overflow
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;释放许可也是简单for循环.现在，我们来看看nonfair和fair的区别。下面是fair类的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
   static final class FairSync extends Sync {
        private static final long serialVersionUID = 2014338818796000944L;

        FairSync(int permits) {
            super(permits);
        }

        protected int tryAcquireShared(int acquires) {
            for (;;) {
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FairSync和NonfairSync的区别是在获取许可的地方，FairSync获取许可的时候，hasQueuedPredecessors使用这个方法判断阻塞队列中是否有线程在排队&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;
    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &amp;&amp;
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FairSync的做法跟NonfairSync的区别就是，在许可用完的情况下，FairSync是把线程阻塞住，放入等待队列,而NonfairSync的做法是，不管当前是否有线程在排队，NonfairSync始终重试去获取许可，这会导致当前线程可能会优先于等待队列中的线程获得许可。&lt;/p&gt;
</content>
</entry>
</feed>